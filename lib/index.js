// Generated by CoffeeScript 2.3.1
var bestChoice, countDependencies, expandPhrase, expandSynonym, expandToken, fixPunctuation, flatten, fs, generate, getPhraseDependencies, inspect, nearley, parse, parser_grammar, randomChoice, sortBy, unparse,
  indexOf = [].indexOf;

nearley = require('nearley');

fs = require('fs');

parser_grammar = require('./grammar');

({inspect, sortBy, flatten, randomChoice, fixPunctuation} = require('./helpers'));

// Parse and index blocks (phrase and synonym sections)
// ------------------------------------------------------------------------------
exports.parse = parse = function(grammar_string) {
  var grammar, parsed, parser, phrase_key, phrases, ref;
  if (grammar_string.endsWith('.nlg')) {
    grammar_string = fs.readFileSync(grammar_string, 'utf8');
  }
  grammar_string = grammar_string.trim();
  parser = new nearley.Parser(parser_grammar.ParserRules, parser_grammar.ParserStart);
  parser.feed(grammar_string);
  parsed = parser.results[0];
  // inspect 'parsed', parsed
  grammar = {
    phrases: {},
    synonyms: {}
  };
  parsed.forEach(function(block) {
    // inspect 'block', block
    if (block.phrase) {
      return grammar.phrases[block.phrase] = block;
    } else if (block.phrase === '') {
      return grammar.phrases.root = block;
    } else if (block.synonym) {
      return grammar.synonyms[block.synonym] = block;
    }
  });
  ref = grammar.phrases;
  for (phrase_key in ref) {
    phrases = ref[phrase_key];
    phrases.lines.forEach(function(phrase, pi) {
      return phrase.dependencies = getPhraseDependencies(phrase, grammar);
    });
  }
  return grammar;
};

// Helper for turning a parsed phrase back into a string, used in error messages
unparse = function(phrase) {
  var unparsed;
  unparsed = "";
  phrase.map(function(token) {
    if (token.word) {
      unparsed += token.word;
    } else if (token.value) {
      unparsed += "$" + token.value;
    }
    if (token.formatter) {
      unparsed += "|" + token.formatter;
    } else if (token.synonym) {
      unparsed += "~" + token.synonym;
    } else if (token.phrase) {
      unparsed += "%" + token.phrase;
    }
    return unparsed += " ";
  });
  return unparsed.trim();
};

// Attach chain of dependencies to phrases
// ------------------------------------------------------------------------------
// In order to efficiently support phrase selection (see next) each phrase needs
// a "chain of dependencies" which specifies which values are required to expand
// this phrase.
getPhraseDependencies = function(phrase, grammar) {
  var phrase_phrases, phrase_values, sub_dependencies;
  phrase_values = phrase.filter(function(token) {
    return token.value != null;
  }).map(function(token) {
    return token.value;
  });
  phrase_phrases = phrase.filter(function(token) {
    return token.phrase != null;
  }).map(function(token) {
    return token.phrase;
  });
  sub_dependencies = flatten(flatten(phrase_phrases.map(function(phrase_key) {
    if (!grammar.phrases[phrase_key]) {
      throw `No such phrase %${phrase_key}`;
    }
    return grammar.phrases[phrase_key].lines.map(function(phrase, pi) {
      return getPhraseDependencies(phrase, grammar);
    });
  })));
  return phrase_values.concat(sub_dependencies);
};

// Choosing a phrase given known values
// ------------------------------------------------------------------------------
// Phrases are chosen based on how many values are satisfied by the values object
// - ideally there is a one to one correlation. A phrase with values that are not
// in the values object will not be chosen, but it is acceptable to have values in
// the values object that are not used in the phrase (with the consideration that
// they are likely used in another phrase). The best phrase is considered the
// one with the most matching values, or a random selection if there are
// several good options.

// In the case that a phrase expands into further sub-phrases, those phrases have
// to be checked to verify the parent's validity. This might be done by pre-
// attaching a chain of dependencies right after parsing.
countDependencies = function(phrase) {
  return phrase.dependencies.length;
};

bestChoice = function(phrases, values) {
  var available_values, best_count, best_phrases, dependency, error_message, filtered_phrases, i, j, len, len1, phrase, ref, value_counts;
  available_values = Object.keys(values);
  // Filter out unusable phrases (those with values not provided by object)
  filtered_phrases = phrases.filter(function(phrase) {
    var dependency, i, len, ref;
    ref = phrase.dependencies;
    for (i = 0, len = ref.length; i < len; i++) {
      dependency = ref[i];
      if (indexOf.call(available_values, dependency) < 0) {
        return false;
      }
    }
    return true;
  });
  if (filtered_phrases.length === 0) {
    // Go back and count which dependencies are missing per phrase
    error_message = "No usable phrases, missing values for phrases:\n";
    for (i = 0, len = phrases.length; i < len; i++) {
      phrase = phrases[i];
      error_message += '    ' + unparse(phrase) + '\n';
      ref = phrase.dependencies;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        dependency = ref[j];
        if (indexOf.call(available_values, dependency) < 0) {
          error_message += '        $' + dependency + '\n';
        }
      }
    }
    throw error_message;
  }
  // Select best phrases (those with highest number of available values)
  value_counts = filtered_phrases.map(countDependencies);
  best_phrases = sortBy(filtered_phrases, countDependencies);
  best_count = countDependencies(best_phrases[0]);
  best_phrases = best_phrases.filter(function(phrase) {
    return countDependencies(phrase) === best_count;
  });
  // Choose one of best phrases
  return randomChoice(best_phrases);
};

// Expanding phrases into strings
// ------------------------------------------------------------------------------
expandToken = function(token, grammar, context) {
  var expanded, expander, formatted, formatter, group_expanded, group_token, i, item, joiner, len, phrase, phrase_expanded, phrase_token, ref, ref1, secondary, synonym, synonym_token, tokenExpander, value, value_token, word_token;
  // inspect 'expandToken', token
  expanded = [];
  // Expand a word (nothing else to do here)
  if (word_token = token.word) {
    expanded.push(word_token);
  // Expand a group (an array of tokens)
  } else if (group_token = token.group) {
    group_expanded = token.group.map(function(token) {
      return expandToken(token, grammar, context);
    });
    expanded.push(group_expanded.join(' '));
  // Expand a phrase
  } else if (phrase_token = token.phrase) {
    phrase = grammar.phrases[phrase_token];
    phrase_expanded = expandPhrase(phrase, grammar, context);
    expanded.push(phrase_expanded);
  // Expand a synonym (usually simple random choice)
  } else if (synonym_token = token.synonym) {
    synonym = grammar.synonyms[synonym_token];
    expanded.push(expandSynonym(synonym, grammar, context));
  // Expand a value, possibly an array with joiners, possibly formatted
  } else if (value_token = token.value) {
    value = context.values[value_token];
    if (expander = token.expander) {
      tokenExpander = function(item) {
        var item_context;
        // inspect 'item', item
        item_context = Object.assign({}, context, {
          values: item
        });
        return expandToken({
          phrase: expander
        }, grammar, item_context);
      };
      if (Array.isArray(value)) {
        value = value.map(tokenExpander);
      } else {
        value = tokenExpander(value);
      }
    }
    if (Array.isArray(value) && (joiner = token.joiner)) {
      if (value.length === 1) {
        expanded.push(value[0]);
        return expanded;
      }
      ref = value.slice(0, -2);
      // Up to second to last item with regular joiner
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        expanded.push(item);
        expanded.push(expandToken(joiner, grammar, context));
      }
      // Second to last item, last joiner
      if (secondary = token.secondary) {
        expanded.push(value.slice(-2)[0]);
        if (token.oxford) {
          expanded.push(expandToken(joiner, grammar, context));
        }
        expanded.push(expandToken(secondary, grammar, context));
      } else {
        expanded.push(value.slice(-2)[0]);
        expanded.push(expandToken(joiner, grammar, context));
      }
      // Last item
      expanded.push(value.slice(-1)[0]);
    } else if (formatter = token.formatter) {
      if (!((ref1 = context.formatters) != null ? ref1[formatter] : void 0)) {
        throw `No such formatter '${formatter}'`;
      }
      formatted = context.formatters[formatter](value);
      expanded.push(formatted);
    } else {
      expanded.push(value);
    }
  }
  return expanded;
};

expandPhrase = function(phrase, grammar, context) {
  var expanded, i, len, line, token;
  expanded = [];
  line = bestChoice(phrase.lines, context.values);
  for (i = 0, len = line.length; i < len; i++) {
    token = line[i];
    expanded = expanded.concat(expandToken(token, grammar, context));
  }
  return expanded.join(' ');
};

// TODO: Should it be required that synonyms do not contain values?
expandSynonym = function(synonym, grammar, context) {
  var expanded, i, len, line, token;
  expanded = [];
  line = randomChoice(synonym.lines);
  for (i = 0, len = line.length; i < len; i++) {
    token = line[i];
    expanded = expanded.concat(expandToken(token, grammar, context));
  }
  return expanded.join(' ');
};

exports.generate = generate = function(grammar, context, root_node = 'root') {
  return fixPunctuation(expandPhrase(grammar.phrases[root_node], grammar, context));
};

exports.generate.fromPlainString = function(grammar_string, context) {
  var grammar;
  grammar_string = '%\n\t' + grammar_string;
  grammar = parse(grammar_string);
  return generate(grammar, context);
};
